/**
 * Source of Truth (SOT) API
 * Extracted from server.js
 *
 * Handles:
 * - GET /api/source-of-truth
 * - GET /api/sot/enhanced, health, insights, alerts, delta
 * - GET /api/sot/timeline, /api/timeline
 * - GET /api/sot/versions, versions/:id
 * - GET /api/sot/compare
 * - GET /api/sot/trace/:type/:id
 * - POST /api/sot/executive-summary, sot/chat
 * - PUT /api/sot/facts/:id, sot/decisions/:id
 * - GET /api/sot/export/:format
 */

const { parseBody, parseUrl } = require('../../server/request');
const { getLogger } = require('../../server/requestContext');
const { logError } = require('../../logger');
const { jsonResponse } = require('../../server/response');
const llmConfig = require('../../llm/config');

function convertMarkdownToHTML(md) {
    return md
        .replace(/^#### (.*$)/gim, '<h5>$1</h5>')
        .replace(/^### (.*$)/gim, '<h4>$1</h4>')
        .replace(/^## (.*$)/gim, '<h3>$1</h3>')
        .replace(/^# (.*$)/gim, '<h2>$1</h2>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/^\| (.+) \|$/gim, (match, content) => {
            const cells = content.split('|').map(c => c.trim());
            if (cells.every(c => c.match(/^-+$/))) return '';
            const tag = cells[0].match(/^-+$/) ? 'td' : 'td';
            return '<tr>' + cells.map(c => `<${tag}>${c}</${tag}>`).join('') + '</tr>';
        })
        .replace(/^- (.*$)/gim, '<li>$1</li>')
        .replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>')
        .replace(/^---$/gim, '<hr>')
        .replace(/\n\n/g, '</p><p>')
        .replace(/\n/g, '<br>');
}

function generateStandaloneHTML(markdown, health, insights) {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Source of Truth - ${new Date().toISOString().split('T')[0]}</title>
    <style>
        :root { --accent: #e94560; --bg: #0f0f23; --card: #1a1a2e; --text: #eaeaea; --muted: #888; --success: #2ecc71; --warning: #f39c12; --danger: #e74c3c; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; padding: 40px; }
        .container { max-width: 1000px; margin: 0 auto; }
        .header { text-align: center; margin-bottom: 40px; padding-bottom: 20px; border-bottom: 2px solid var(--accent); }
        .header h1 { color: var(--accent); font-size: 2.5em; margin-bottom: 10px; }
        .health-badge { display: inline-block; padding: 8px 20px; border-radius: 20px; font-weight: bold; font-size: 1.1em; background: ${health.color}22; color: ${health.color}; border: 2px solid ${health.color}; }
        .insights { display: grid; gap: 15px; margin: 30px 0; }
        .insight { background: var(--card); padding: 15px; border-radius: 8px; border-left: 4px solid var(--accent); }
        .insight-title { font-weight: bold; margin-bottom: 5px; }
        .content { background: var(--card); padding: 30px; border-radius: 12px; }
        h2 { color: var(--accent); margin: 25px 0 15px; padding-bottom: 8px; border-bottom: 1px solid #333; }
        h3 { color: var(--accent); margin: 20px 0 10px; }
        table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        th, td { padding: 10px; text-align: left; border: 1px solid #333; }
        th { background: #16213e; color: var(--text); }
        ul { padding-left: 25px; margin: 10px 0; }
        li { margin: 5px 0; }
        hr { border: none; border-top: 1px solid #333; margin: 25px 0; }
        .footer { text-align: center; margin-top: 40px; color: var(--muted); font-size: 0.9em; }
        @media print { body { background: white; color: black; } .health-badge, th { background: #f5f5f5 !important; color: black !important; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìã Source of Truth</h1>
            <p style="color: var(--muted);">Generated: ${new Date().toLocaleString()}</p>
            <div class="health-badge">Health Score: ${health.score}/100 - ${health.status}</div>
        </div>
        ${insights.length > 0 ? `
        <div class="insights">
            <h3>üîç Key Insights</h3>
            ${insights.slice(0, 5).map(i => `
                <div class="insight">
                    <div class="insight-title">${i.icon || ''} ${i.title}</div>
                    <div>${i.message}</div>
                </div>
            `).join('')}
        </div>
        ` : ''}
        <div class="content">
            ${convertMarkdownToHTML(markdown)}
        </div>
        <div class="footer">
            <p>Generated by GodMode Source of Truth Engine</p>
        </div>
    </div>
</body>
</html>`;
}

async function handleSot(ctx) {
    const { req, res, pathname, storage, processor, config, llm } = ctx;
    const llmConfig = require('../../llm/config');
    const log = getLogger().child({ module: 'sot' });
    const { SourceOfTruthEngine } = require('../../advanced/SourceOfTruthEngine');

    // GET /api/source-of-truth
    if (pathname === '/api/source-of-truth' && req.method === 'GET') {
        try {
            const md = await processor.generateSourceOfTruth();
            jsonResponse(res, { content: md });
        } catch (e) {
            log.warn({ event: 'sot_generate_error', reason: e?.message }, 'Error generating Source of Truth');
            jsonResponse(res, { content: '# Source of Truth\n\nError generating content: ' + e.message });
        }
        return true;
    }

    // GET /api/sot/enhanced
    if (pathname === '/api/sot/enhanced' && req.method === 'GET') {
        try {
            const sotEngine = new SourceOfTruthEngine(storage, processor);
            const parsedUrl = parseUrl(req.url);
            const includeGraph = parsedUrl.query.graph === 'true';
            const includeAI = parsedUrl.query.ai === 'true';
            const textCfg = llmConfig.getTextConfig(config);
            const llmProviderAdapter = includeAI && textCfg.provider && textCfg.model ? {
                generateText: async (prompt) => {
                    const r = await llm.generateText({
                        provider: textCfg.provider,
                        model: textCfg.model,
                        providerConfig: textCfg.providerConfig || {},
                        prompt,
                        context: 'sot_summary'
                    });
                    return (r && r.text) ? r.text : '';
                }
            } : null;
            const enhanced = await sotEngine.generateEnhancedSOT({
                includeGraph,
                includeAISummary: includeAI,
                llmProvider: llmProviderAdapter
            });
            jsonResponse(res, enhanced);
        } catch (e) {
            log.warn({ event: 'sot_enhanced_error', reason: e?.message }, 'Error generating enhanced SOT');
            jsonResponse(res, { error: e.message }, 500);
        }
        return true;
    }

    // GET /api/sot/health
    if (pathname === '/api/sot/health' && req.method === 'GET') {
        try {
            const sotEngine = new SourceOfTruthEngine(storage);
            const health = await sotEngine.calculateHealthScore();
            jsonResponse(res, health || { score: 0, status: 'Unknown', color: '#888', factors: [] });
        } catch (e) {
            log.warn({ event: 'sot_health_error', reason: e?.message }, '/api/sot/health error');
            jsonResponse(res, { score: 0, status: 'Error', color: '#888', factors: [], error: e.message }, 200);
        }
        return true;
    }

    // GET /api/sot/insights
    if (pathname === '/api/sot/insights' && req.method === 'GET') {
        try {
            const sotEngine = new SourceOfTruthEngine(storage);
            const insights = await sotEngine.generateInsights();
            jsonResponse(res, { insights: insights || [] });
        } catch (e) {
            log.warn({ event: 'sot_insights_error', reason: e?.message }, '/api/sot/insights error');
            jsonResponse(res, { insights: [], error: e.message }, 200);
        }
        return true;
    }

    // GET /api/sot/alerts
    if (pathname === '/api/sot/alerts' && req.method === 'GET') {
        try {
            const sotEngine = new SourceOfTruthEngine(storage);
            const alerts = await sotEngine.generateAlerts();
            jsonResponse(res, { alerts: alerts || [] });
        } catch (e) {
            log.warn({ event: 'sot_alerts_error', reason: e?.message }, '/api/sot/alerts error');
            jsonResponse(res, { alerts: [], error: e.message }, 200);
        }
        return true;
    }

    // GET /api/sot/delta
    if (pathname === '/api/sot/delta' && req.method === 'GET') {
        try {
            const sotEngine = new SourceOfTruthEngine(storage);
            const delta = sotEngine.getChangeDelta();
            jsonResponse(res, delta);
        } catch (e) {
            jsonResponse(res, { error: e.message }, 500);
        }
        return true;
    }

    // GET /api/sot/timeline
    if (pathname === '/api/sot/timeline' && req.method === 'GET') {
        try {
            const sotEngine = new SourceOfTruthEngine(storage);
            const timeline = await sotEngine.generateTimeline();
            const parsedUrl = parseUrl(req.url);
            const limit = parseInt(parsedUrl.query.limit) || 50;
            jsonResponse(res, { timeline: timeline.slice(0, limit) });
        } catch (e) {
            jsonResponse(res, { error: e.message }, 500);
        }
        return true;
    }

    // GET /api/timeline
    if (pathname === '/api/timeline' && req.method === 'GET') {
        try {
            const sotEngine = new SourceOfTruthEngine(storage);
            const timeline = await sotEngine.generateTimeline();
            const parsedUrl = parseUrl(req.url);
            const limit = parseInt(parsedUrl.query.limit) || 200;
            const types = parsedUrl.query.types ? String(parsedUrl.query.types).split(',') : null;
            const startDate = parsedUrl.query.startDate || null;
            const endDate = parsedUrl.query.endDate || null;

            let filtered = timeline;
            if (types && types.length > 0) {
                filtered = filtered.filter(e => types.includes(e.type));
            }
            if (startDate) {
                filtered = filtered.filter(e => e.date && e.date >= startDate);
            }
            if (endDate) {
                filtered = filtered.filter(e => e.date && e.date <= endDate);
            }

            const sliced = filtered.slice(0, limit);
            const start = sliced.length ? sliced[sliced.length - 1].date : '';
            const end = sliced.length ? sliced[0].date : '';

            jsonResponse(res, {
                events: sliced,
                totalEvents: filtered.length,
                startDate: start,
                endDate: end
            });
        } catch (e) {
            jsonResponse(res, { error: e.message, events: [], totalEvents: 0, startDate: '', endDate: '' }, 500);
        }
        return true;
    }

    // GET /api/sot/versions
    if (pathname === '/api/sot/versions' && req.method === 'GET') {
        try {
            const sotEngine = new SourceOfTruthEngine(storage);
            const versions = sotEngine.getVersionHistory();
            jsonResponse(res, { versions });
        } catch (e) {
            jsonResponse(res, { error: e.message }, 500);
        }
        return true;
    }

    // GET /api/sot/versions/:id
    if (pathname.match(/^\/api\/sot\/versions\/\d+$/) && req.method === 'GET') {
        try {
            const versionId = pathname.split('/').pop();
            const sotEngine = new SourceOfTruthEngine(storage);
            const version = sotEngine.getVersion(versionId);
            if (version) {
                jsonResponse(res, version);
            } else {
                jsonResponse(res, { error: 'Version not found' }, 404);
            }
        } catch (e) {
            jsonResponse(res, { error: e.message }, 500);
        }
        return true;
    }

    // GET /api/sot/compare
    if (pathname === '/api/sot/compare' && req.method === 'GET') {
        try {
            const parsedUrl = parseUrl(req.url);
            const v1 = parsedUrl.query.v1;
            const v2 = parsedUrl.query.v2;
            if (!v1 || !v2) {
                jsonResponse(res, { error: 'Missing v1 or v2 parameters' }, 400);
                return true;
            }
            const sotEngine = new SourceOfTruthEngine(storage);
            const diff = sotEngine.compareVersions(v1, v2);
            jsonResponse(res, diff || { error: 'Could not compare versions' });
        } catch (e) {
            jsonResponse(res, { error: e.message }, 500);
        }
        return true;
    }

    // GET /api/sot/trace/:type/:id
    if (pathname.match(/^\/api\/sot\/trace\/\w+\/\d+$/) && req.method === 'GET') {
        try {
            const parts = pathname.split('/');
            const itemType = parts[4];
            const itemId = parts[5];
            const sotEngine = new SourceOfTruthEngine(storage);
            const trace = sotEngine.getSourceTraceability(itemType, itemId);
            jsonResponse(res, trace || { found: false });
        } catch (e) {
            jsonResponse(res, { error: e.message }, 500);
        }
        return true;
    }

    // POST /api/sot/executive-summary
    if (pathname === '/api/sot/executive-summary' && req.method === 'POST') {
        try {
            const sotEngine = new SourceOfTruthEngine(storage, processor);
            const summary = await sotEngine.generateExecutiveSummary();
            jsonResponse(res, summary);
        } catch (e) {
            jsonResponse(res, { error: e.message }, 500);
        }
        return true;
    }

    // POST /api/sot/chat
    if (pathname === '/api/sot/chat' && req.method === 'POST') {
        try {
            const body = await parseBody(req);
            const { message, model } = body;

            const sotEngine = new SourceOfTruthEngine(storage);
            const health = sotEngine.calculateHealthScore();
            const insights = sotEngine.generateInsights();

            const facts = storage.getFacts();
            const decisions = storage.getDecisions();
            const risks = storage.getRisks ? await storage.getRisks() : [];
            const actions = storage.getActionItems();

            const sotContext = `
You are an AI assistant with access to this project's Source of Truth knowledge base.

PROJECT HEALTH: ${health.score}/100 (${health.status})

FACTS (${facts.length} total):
${facts.slice(0, 20).map(f => `- [${f.category}] ${f.content}`).join('\n')}

DECISIONS (${decisions.length} total):
${decisions.slice(0, 10).map(d => `- ${d.content} (${d.owner || 'N/A'})`).join('\n')}

RISKS (${risks.length} total):
${risks.slice(0, 10).map(r => `- [${r.impact}/${r.status}] ${r.content}`).join('\n')}

PENDING ACTIONS (${actions.filter(a => a.status === 'pending').length}):
${actions.filter(a => a.status === 'pending').slice(0, 10).map(a => `- ${a.task} (${a.owner || 'N/A'})`).join('\n')}

KEY INSIGHTS:
${insights.slice(0, 5).map(i => `- ${i.title}: ${i.message}`).join('\n')}

Answer questions about this project based on the knowledge above. Be specific and reference facts when possible.`;

            const sotTextCfg = llmConfig.getTextConfig(config, { model });
            const result = await llm.generateText({
                provider: sotTextCfg.provider,
                providerConfig: sotTextCfg.providerConfig,
                model: sotTextCfg.model,
                system: sotContext,
                prompt: message,
                temperature: 0.7,
                maxTokens: 2048,
                context: 'sot_chat',
                priority: 'high'
            });

            if (!result.success) {
                jsonResponse(res, { error: result.error || 'Failed to generate response' }, 500);
                return true;
            }

            jsonResponse(res, {
                response: result.text,
                model: sotTextCfg.model,
                healthScore: health.score
            });
        } catch (e) {
            jsonResponse(res, { error: e.message }, 500);
        }
        return true;
    }

    // PUT /api/sot/facts/:id
    if (pathname.match(/^\/api\/sot\/facts\/\d+$/) && req.method === 'PUT') {
        try {
            const factId = parseInt(pathname.split('/').pop());
            const body = await parseBody(req);

            const facts = storage.knowledge.facts || [];
            const factIndex = facts.findIndex(f => f.id === factId);

            if (factIndex === -1) {
                jsonResponse(res, { error: 'Fact not found' }, 404);
                return true;
            }

            if (body.content) facts[factIndex].content = body.content;
            if (body.category) facts[factIndex].category = body.category;
            facts[factIndex].edited_at = new Date().toISOString();
            facts[factIndex].edited_by = 'user';

            storage.saveKnowledge();
            jsonResponse(res, { success: true, fact: facts[factIndex] });
        } catch (e) {
            jsonResponse(res, { error: e.message }, 500);
        }
        return true;
    }

    // PUT /api/sot/decisions/:id
    if (pathname.match(/^\/api\/sot\/decisions\/\d+$/) && req.method === 'PUT') {
        try {
            const decisionId = parseInt(pathname.split('/').pop());
            const body = await parseBody(req);

            const decisions = storage.knowledge.decisions || [];
            const decIndex = decisions.findIndex(d => d.id === decisionId);

            if (decIndex === -1) {
                jsonResponse(res, { error: 'Decision not found' }, 404);
                return true;
            }

            if (body.content) decisions[decIndex].content = body.content;
            if (body.owner) decisions[decIndex].owner = body.owner;
            if (body.category) decisions[decIndex].category = body.category;
            decisions[decIndex].edited_at = new Date().toISOString();

            storage.saveKnowledge();
            jsonResponse(res, { success: true, decision: decisions[decIndex] });
        } catch (e) {
            jsonResponse(res, { error: e.message }, 500);
        }
        return true;
    }

    // GET /api/sot/export/:format
    if (pathname.match(/^\/api\/sot\/export\/\w+$/) && req.method === 'GET') {
        try {
            const format = pathname.split('/').pop();
            const md = processor.generateSourceOfTruth();

            switch (format) {
                case 'markdown':
                case 'md':
                    res.writeHead(200, {
                        'Content-Type': 'text/markdown',
                        'Content-Disposition': 'attachment; filename="source_of_truth.md"'
                    });
                    res.end(md);
                    break;

                case 'html': {
                    const sotEngine = new SourceOfTruthEngine(storage);
                    const health = sotEngine.calculateHealthScore();
                    const insights = sotEngine.generateInsights();
                    const htmlContent = generateStandaloneHTML(md, health, insights);
                    res.writeHead(200, {
                        'Content-Type': 'text/html',
                        'Content-Disposition': 'attachment; filename="source_of_truth.html"'
                    });
                    res.end(htmlContent);
                    break;
                }

                case 'json': {
                    const sotEngineJson = new SourceOfTruthEngine(storage);
                    const enhanced = await sotEngineJson.generateEnhancedSOT({ markAsViewed: false });
                    res.writeHead(200, {
                        'Content-Type': 'application/json',
                        'Content-Disposition': 'attachment; filename="source_of_truth.json"'
                    });
                    res.end(JSON.stringify(enhanced, null, 2));
                    break;
                }

                default:
                    jsonResponse(res, { error: 'Unsupported format. Use: markdown, html, json' }, 400);
            }
        } catch (e) {
            jsonResponse(res, { error: e.message }, 500);
        }
        return true;
    }

    return false;
}

module.exports = { handleSot };
